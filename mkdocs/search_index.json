{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/reference/",
            "text": "Syntax\n\n\nVariables\n\n\nVTL support two type of variable names, regular names and escaped names.\nRegular variable names in must start with a letter followed by letters, numbers\nand the underscore (\n_\n) characters. Escaped variable names must be enclosed by single\nquotes (\n'\n) and can contain any characters except new lines. Single quotes can be escaped\nby doubling them.\n\n\n\n    \n\nvariableName := value\naVariableName1 := value\n'1Variable' := value\n'variable''with''quotes' := value\n    \n\n\n\n\n\nComments\n\n\nLine comments are prefixed with two slashes ('//'). Block comments are\nsurrounded by \n/*\n and \n*/\n and can contain new lines.\n\n\n\n    \n\n// Single line comment\n/*\n * A block\n * comment\n */\n    \n\n\n\n\n\nData types\n\n\nIntegers\n\n\n\n    \n\nvariable := 1\nvariable := -1\nvariable := 0\n    \n\n\n\n\n\nFloats\n\n\n\n    \n\nvariable := -0.1e-10\nvariable := -0.1e10\nvariable := -0.1e+10\nvariable := 0.1e-10\nvariable := 0.1e10\nvariable := 0.1e+10\nvariable := +0.1e-10\nvariable := +0.1e10\nvariable := +0.1e+10\nvariable := 0.01\nvariable := -0.001\nvariable := +0.0001\n    \n\n\n\n\n\nStrings\n\n\n\n    \n\nvariable := \"STRING\"\nvariable := \"STR\"\"ING\"\n    \n\n\n\n\n\nBooleans\n\n\n\n     \n\nvariable := true\nvariable := false\n     \n\n \n\n\n\nDates and time\n\n\n\n     \n\nvariable := 2000-01-01T00:00:00.000Z\nvariable := 2000-01-01T00:00:00.000+00:15\n     \n\n \n\n\n\nExpression and operators\n\n\nPrecedence\n\n\nOne can adjust the precedence of expressions in VTL using the parenthesis (\n(\n and \n)\n)\n\n\n\n     \n\nvariable := ( expression )\n     \n\n \n\n\n\nArithmetic operators\n\n\nThe multiplication, division, addition and subtraction operators can be\nused with Float and Integer types.\n\n\n\n     \n\nvariable := 1 + 2 / 3 * 4\n     \n\n \n\n\n\nIf Floats and Integers are mixed in the same arithmetic expression the\nresulting number will be Float\n\n\n\n     \n\nfloatVariable := 1 + 2.0\nfloatVariable := 1 * 1.0\n     \n\n\n\n\n\nConcatenation operator\n\n\nThe concatenation operator \n||\n concatenate two strings.\n\n\n\n    \n\ncontac := [data] {\n    result := left || \" \" || right\n}\n\n\n    \n\nleft[I,String],right[I,String]\nHello,World\nnull,World\nHello,null\n    \n\n    \n\n\n\n\n\nString functions\n\n\n\n    \n\nstrings := [data] {\n    withTrailingSpc := \"   \" || value || \"   \",\n    rightTrim := \"[\" || rtrim(withTrailingSpc) || \"]\",\n    leftTrim := \"[\" || ltrim(withTrailingSpc) || \"]\",\n    'trim' := \"[\" || trim(withTrailingSpc) || \"]\",\n    noTrim := \"[\" || withTrailingSpc || \"]\"\n}\n\n\n    \n\nid[I,Long],value[M,String]\n1L,Hello World!\n    \n\n    \n\n\n\n\n\nTrim, ltrim and rtrim functions\n\n\nThe \ntrim\n, \nltrim\n and \nrtrim\n take a \nString\n as input and return a\n\nString\n.\n\n\nThe \nltrim\n and \nrtrim\n functions remove leading (to the left and\ntrailing (to the right) white characters from the given \nString\n,\nrespectively.\n\n\nThe \ntrim\n functions remove both the leading and trailing white\ncharacters.\n\n\n\n    String   trim(String value)\n    String  rtrim(String value)\n    String  ltrim(String value)\n\n\n\n\nUpper and lower function\n\n\n\n    String  upper(String value)\n    String  lower(String value)\n\n\n\n\nThe \nupper\n function transforms all of the characters of the given\n\nString\n to upper case. The \nlower\n functions transforms all the\ncharacters of the given \nString\n to lower case.\n\n\nMathematical functions\n\n\nIn addition to the arithmetic operators, basic mathematical operations\nare available as functions.\n\n\n\n    \n\nmath := [data] {\n    posInteger := data.value,\n    negInteger := data.value * -1,\n    posFloat := data.value / 10,\n    negFloat := negInteger / 10,\n    absFn   := abs(negFloat),\n    logFn   := log(posInteger, posInteger),\n    ceilFn  := ceil(posFloat * 5),\n    floorFn := floor(posFloat * 5),\n    expFn   := exp(posFloat),\n    lnFn    := ln(posInteger),\n    logFn   := log(posInteger, posInteger),\n    powerFn := power(posInteger, posInteger),\n    nrootFn := nroot(posInteger, posInteger),\n    roundFn := round(posFloat, 2)\n}\n\n\n    \n\nvalue[I,Long]\n1L\n3L\n4L\n5L\n6L\n7L\n8L\n9L\n10L\n    \n\n    \n\n\n\n\n\nAbs function\n\n\n\n    Float   abs(Float value)\n    Integer abs(Integer value)\n\n\n\n\nThe \nabs\n function takes an \nInteger\n or a\n\nFloat\n value and returns its absolute value.\n\n\nCeil and Floor functions\n\n\n\n    Integer floor(Float value)\n    Integer ceil(Float value)\n\n\n\n\nThe \nceil\n and \nfloor\n functions take as input a \nFloat\n value and\nreturn an \nInteger\n value.\n\n\nceil\n will return the smallest \nInteger\n value that is greater than the\ngiven value.\n\n\nfloor\n will return the largest \nInteger\n value that is smaller than the\ngiven value.\n\n\nTrunc and Round functions\n\n\n\n    Float trunc(Float value, Integer decimals)\n    Float floor(Float value, Integer decimals)\n\n\n\n\nThe \ntrunc\n and 'round' functions take as input a \nFloat\n value and an\n\nInteger\n that represent a number of decimals. Both \ntrunc\n and \nround\n\nreturn a \nFloat\n.\n\n\ntrunc\n will wil truncate to the decimals whereas \nround\n will round up\nto the decimals.\n\n\nLn function (Napierian logarithm)\n\n\n\n    Float ln(Float value)\n\n\n\n\nExp function\n\n\n\n    Float exp(Integer value)\n    Float exp(Float value)\n\n\n\n\nPower function\n\n\n\n    Float power(Float value, Float exponent)\n\n\n\n\nSqrt function\n\n\n\n    Float sqrt(Float value)\n\n\n\n\nNroot function\n\n\n\n    Float nroot(Float value, Float n)\n\n\n\n\nDatasets\n\n\nRecord\n\n\nProduct\n\n\n()\n\n\nJoin expressions\n\n\nInner join\n\n\n\n    \n\ninnerJoin := [inner left, right] {\n    filter true\n}\n    \n\n    \n\nid[I,String],measure[M,String],attribute[A,String]\n3,left value 3, left attribute 3\n4,left value 4, left attribute 4\n5,left value 5, left attribute 5\n6,left value 6, left attribute 6\n    \n\n    \n\nid[I,String],measure[M,String],attribute[A,String]\n1,right value 1, right attribute 1\n2,right value 2, right attribute 2\n3,right value 3, right attribute 3\n4,right value 4, right attribute 4\n    \n\n    \n\n\n\n\n\nOuter join\n\n\n\n    \n\nouterJoin := [outer left, right] {\n    filter true\n}\n    \n\n    \n\nid1[I,String],id2[I,String],measure[M,String],attribute[A,String]\n1,3,left value 3, left attribute 3\n1,4,left value 4, left attribute 4\n1,5,left value 5, left attribute 5\n1,6,left value 6, left attribute 6\n    \n\n    \n\nid1[I,String],id2[I,String],measure[M,String],attribute[A,String]\n1,1,right value 1, right attribute 1\n1,2,right value 2, right attribute 2\n1,3,right value 3, right attribute 3\n1,4,right value 4, right attribute 4\n    \n\n    \n\n\n\n\n\nFold clause\n\n\nFold transposes a single data point of the input Dataset into several\ndata points. It adds Identifier dim and measure msr to the resulting\nDataset, inserts into the resulting Dataset a data point for each value\nA in the element list and assigns to the inserted data point dim = A and\nmsr = value of measure A in the input Dataset.\n\n\nWhen measure A is null then fold does not create a data point for that\nmeasure. Note that in general unfolding and folding are not exactly\nsymmetric operations, i.e. in some cases the fold operation applied to\nthe unfolded Dataset does not recreate exactly the original Dataset\n(before unfolding).\n\n\n\n    \n\nfolded := [population] {\n    fold '0-14', '15-24', '25-64', '65+' to age, percent\n}\nunfolded := [folded] {\n    unfold age, percent to \"0-14\", \"15-24\"\n}\n    \n\n    \n\ncountry[I,String],0-14[M,String],15-24[M,String],25-64[M,String],65+[M,String]\nFrance ,18.1%,12.2%,51.0%,18.7%\nNorway ,18.6%,13.0%,52.0%,16.4%\nItaly  ,14.0%,9.8%,54.4%,21.7%\nSweden ,17.3%,12.2%,50.5%,20.0%\n    \n\n    \n\n\n\n\n\nUnfold\n\n\n\n    \n\nunfolded := [colors] {\n    unfold color, wavelength to \"indigo\", \"blue\", \"yellow\"\n}\n    \n\n    \n\ncolor[I,String],wavelength[M,String]\nblue, 475nm\nindigo, 445nm\norange, 570nm\nred, 650nm\nviolet, 400 nm\nyellow, 510nm\n    \n\n    \n\n\n\n\n\nCheck operators\n\n\nThe check operators are used to validate data sets. Three check operator\n variants are available, check with rule sets, check with hierarchical\n rule sets and check with single boolean rule.\n\n\nThe return value of the check function depend of parameters.\nWhen used with the parameter \"condition\", the resulting dataset will only\n contain a condition measure of type Boolean indicating if the DataPoint\n is valid according to the rule set, hierarchical rule set or boolean\n expression.\nWith the parameter \"measures\", the resulting dataset contains all the\nmeasures of the input dataset.\n\n\nCheck with single rule\n\n\n\n    \n\nfolded := check(data.valid <> \"na\")\n    \n\n    \n\ncountry[I,String],population[M,String]\nFrance , 64M\nNorway , 5M\nItaly  , na\nSweden , 9M\n    \n\n    \n\n\n\n\nConditional operators\n\n\nnvl\n\n\nThe operator nvl replaces null values with a value given as a parameter.\n\n\n    \n\njoin := [outer left, right] {\n    nvl_result := nvl(right.value, \"was null\")\n}\n    \n\n    \n\nid1[I,String],id2[I,String],value[M,String],attribute[A,String]\n1,3,left value 3, left attribute 3\n1,4,left value 4, left attribute 4\n1,5,left value 5, left attribute 5\n1,6,left value 6, left attribute 6\n    \n\n    \n\nid1[I,String],id2[I,String],value[M,String],attribute[A,String]\n1,1,right value 1, right attribute 1\n1,2,right value 2, right attribute 2\n1,3,right value 3, right attribute 3\n1,4,right value 4, right attribute 4\n    \n\n    \n\n\n\n\nBoolean operators\n\n\nNull operators\n\n\nVTL adopts 3VL (three-value logic); null is not considered a \"value\",\n but rather a marker (or placeholder) indicating the absence of value.\n\n\n\n\n\n\n\n\np\n\n\nq\n\n\np\n  OR \nq\n\n\np\n  AND \nq\n\n\np\n  = \nq\n\n\n\n\n\n\n\n\n\n\nTrue\n\n\nTrue\n\n\nTrue\n\n\nTrue\n\n\nTrue\n\n\n\n\n\n\nTrue\n\n\nFalse\n\n\nTrue\n\n\nFalse\n\n\nFalse\n\n\n\n\n\n\nTrue\n\n\nUnknown\n\n\nTrue\n\n\nUnknown\n\n\nUnknown\n\n\n\n\n\n\nFalse\n\n\nTrue\n\n\nTrue\n\n\nFalse\n\n\nFalse\n\n\n\n\n\n\nFalse\n\n\nFalse\n\n\nFalse\n\n\nFalse\n\n\nTrue\n\n\n\n\n\n\nFalse\n\n\nUnknown\n\n\nUnknown\n\n\nFalse\n\n\nUnknown\n\n\n\n\n\n\nUnknown\n\n\nTrue\n\n\nTrue\n\n\nUnknown\n\n\nUnknown\n\n\n\n\n\n\nUnknown\n\n\nFalse\n\n\nUnknown\n\n\nFalse\n\n\nUnknown\n\n\n\n\n\n\nUnknown\n\n\nUnknown\n\n\nUnknown\n\n\nUnknown\n\n\nUnknown\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np\n\n\nNOT \np\n\n\n\n\n\n\n\n\n\n\nTrue\n\n\nFalse\n\n\n\n\n\n\nFalse\n\n\nTrue\n\n\n\n\n\n\nUnknown\n\n\nUnknown\n\n\n\n\n\n\n\n\nNull in boolean operators evaluates to false. In order to test whether\n or not a value is null one can use the postfix operator \nis null\n or\n \nis not null\n as well as the functional equivalents \nisnull()\n or\n \nnot(isnull())\n.\n\n\n\n    \n\npostfixIsNull := [data] {\n    filter value is null\n}\npostfixIsNotNull := [data] {\n    filter value is not null\n}\n\nfunctionalIsNull := [data] {\n    filter isnull(value) \n}\n\nfunctionalIsNotNull := [data] {\n    filter not(isnull(value))\n}\n    \n\n    \n\ncountry[I,String],value[M,String]\nNull , null\nNotNull , value\n    \n\n    \n\n\n\n\n\nHierarchy operator\n\n\nThe hierarchy operator aggregates all measures of a dataset mapping one\nidentifier with a hierarchy.\n\n\nFor instance, consider the following hierarchy:\n\n\n\n\nWorld\n\n\nEurope\n\n\nEastern Europe\n\n\nPoland\n\n\nUkraine\n\n\nRomania\n\n\nHungary\n\n\nSlovakia\n\n\n...\n\n\n\n\n\n\nNorthern Europe\n\n\nDenmark\n\n\nNorway\n\n\nSweden\n\n\nIceland\n\n\n...\n\n\n\n\n\n\nSouthern Europe\n\n\nItaly\n\n\nSpain\n\n\nPortugal\n\n\n...\n\n\n\n\n\n\nWestern Europe\n\n\nBelgium\n\n\nFrance\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\nresult := hierarchy(data, data.region, world, true)\n    \n\n    \n\nyear[I,String],region[I,String],pop[M,Long]\n2000,Belgium,2000L\n2000,Denmark,2000L\n2000,France,2000L\n2000,Hungary,2000L\n2000,Iceland,2000L\n2000,Italy,2000L\n2000,Norway,2000L\n2000,Poland,2000L\n2000,Portugal,2000L\n2000,Romania,2000L\n2000,Slovakia,2000L\n2000,Spain,2000L\n2000,Sweden,2000L\n2000,Ukraine,2000L\n2002,Belgium,2002L\n2002,Denmark,2002L\n2002,France,2002L\n2002,Hungary,2002L\n2002,Iceland,2002L\n2002,Italy,2002L\n2002,Norway,2002L\n2002,Poland,2002L\n2002,Portugal,2002L\n2002,Romania,2002L\n2002,Slovakia,2002L\n2002,Spain,2002L\n2002,Sweden,2002L\n2002,Ukraine,2002L\n2004,Belgium,2004L\n2004,Denmark,2004L\n2004,France,2004L\n2004,Hungary,2004L\n2004,Iceland,2004L\n2004,Italy,2004L\n2004,Norway,2004L\n2004,Poland,2004L\n2004,Portugal,2004L\n2004,Romania,2004L\n2004,Slovakia,2004L\n2004,Spain,2004L\n2004,Sweden,2004L\n2004,Ukraine,2004L\n    \n\n    \n\nfrom[I,String],to[I,String],sign[M,String]\nWestern Europe,Europe,+\nEastern Europe,Europe,+\nSouthern Europe,Europe,+\nNorthern Europe,Europe,+\nBelgium,Western Europe,+\nDenmark,Northern Europe,+\nFrance,Western Europe,+\nHungary,Eastern Europe,+\nIceland,Northern Europe,+\nItaly,Southern Europe,+\nNorway,Northern Europe,+\nPoland,Eastern Europe,+\nPortugal,Southern Europe,+\nRomania,Eastern Europe,+\nSlovakia,Eastern Europe,+\nSpain,Southern Europe,+\nSweden,Northern Europe,+\nUkraine,Eastern Europe,+\n        \n\n    \n\n\n\n\n\nString operators\n\n\nsubstr\n\n\n\n    String substr(Integer startPosition, Integer length)\n\n\n\nThe \nsubstr\n operator takes as input \nstartPosition\n which is the index of the character\nin the string from which the substring is performed and \nlength\n which is the number of\nthe characters in the string to be taken starting from \nstartPosition\n. \nThe operator returns a \nString\n value.\n\n\n\n    \n\nresult := [data] {\n    sub := substr(M1, 5, 6)\n}\n    \n\n    \n\nID[I,String],M1[M,String]\n1 , hello world\n2 , hello\n3 , null\n    \n\n    \n\n\n\n\n\ndate_from_string\n\n\nThe operator date_from_string converts a string into a date.\n\n\n    \n\njoin := [left] {\n    b := date_from_string(M1, \"YYYY\")\n}\n    \n\n    \n\nID[I,String],M1[M,String]\n1 , 2016\n2 , 2017\n3 , null\n    \n\n    \n\n\n\n\nOperators outside the specification\n\n\ninteger_from_string\n\n\nNote \n    This operator is not part of the VTL 1.1 specification.\n\n\n\n\n    Integer integer_from_string(String value)\n\n\n\n\nThe \ninteger_from_string\n operator takes as input a \nString\n value and returns an \nInteger\n value.\n\n\n    \n\njoin := [data] {\n    integerFromString := integer_from_string(M1)\n}\n    \n\n    \n\nID[I,String],M1[M,String]\n1 , 10\n2 , 101\n3 , null\n    \n\n    \n\n\n\n\nfloat_from_string\n\n\nNote \n    This operator is not part of the VTL 1.1 specification.\n\n\n\n\n    Float float_from_string(String value)\n\n\n\n\nThe \nfloat_from_string\n operator takes as input a \nString\n value and returns an \nFloat\n value. The input\nvalue format is described in detail in section 3.10.2 of the Java Language Specification.\nAdditionally a comma (\n,\n) is allowed as a decimal point.\n\n\n    \n\njoin := [data] {\n    floatFromString := float_from_string(M1)\n}\n    \n\n    \n\nID[I,String],M1[M,String]\n1  , -0.1e-10\n2  , -0.1e10\n3  , -0.1e+10\n4  , 0.1e-10\n5  , 0.1e10\n6  , 0.1e+10\n7  , +0.1e-10\n8  , +0.1e10\n9  , +0.1e+10\n10 , 0.01\n11 , -0.001\n12 , +0.0001\n13 , null\n    \n\n    \n\n\n\n\nstring_from_number\n\n\nNote \n    This operator is not part of the VTL 1.1 specification.\n\n\n\n\n    String string_from_number(Number value)\n\n\n\n\nThe \nstring_from_number\n operator takes as input a \nNumber\n value and returns an \nString\n value.\nThe exact result of this operator is described in the documentation of \njava.lang.Double.toString()\n\nand \njava.lang.Long.toString()\n methods available at \nOracle Java Help Center\n.\n\n\n    \n\njoin := [data] {\n    stringFromInteger := string_from_number(M1),\n    stringFromFloat := string_from_number(M2)\n}\n    \n\n    \n\nID[I,String],M1[M,Long],M2[M,Double]\n1 , 10, 10.01\n2 , 0, -0.001\n3 , null, null",
            "title": "Reference"
        },
        {
            "location": "/reference/#syntax",
            "text": "",
            "title": "Syntax"
        },
        {
            "location": "/reference/#variables",
            "text": "VTL support two type of variable names, regular names and escaped names.\nRegular variable names in must start with a letter followed by letters, numbers\nand the underscore ( _ ) characters. Escaped variable names must be enclosed by single\nquotes ( ' ) and can contain any characters except new lines. Single quotes can be escaped\nby doubling them.  \n     \nvariableName := value\naVariableName1 := value\n'1Variable' := value\n'variable''with''quotes' := value",
            "title": "Variables"
        },
        {
            "location": "/reference/#comments",
            "text": "Line comments are prefixed with two slashes ('//'). Block comments are\nsurrounded by  /*  and  */  and can contain new lines.  \n     \n// Single line comment\n/*\n * A block\n * comment\n */",
            "title": "Comments"
        },
        {
            "location": "/reference/#data-types",
            "text": "",
            "title": "Data types"
        },
        {
            "location": "/reference/#integers",
            "text": "variable := 1\nvariable := -1\nvariable := 0",
            "title": "Integers"
        },
        {
            "location": "/reference/#floats",
            "text": "variable := -0.1e-10\nvariable := -0.1e10\nvariable := -0.1e+10\nvariable := 0.1e-10\nvariable := 0.1e10\nvariable := 0.1e+10\nvariable := +0.1e-10\nvariable := +0.1e10\nvariable := +0.1e+10\nvariable := 0.01\nvariable := -0.001\nvariable := +0.0001",
            "title": "Floats"
        },
        {
            "location": "/reference/#strings",
            "text": "variable := \"STRING\"\nvariable := \"STR\"\"ING\"",
            "title": "Strings"
        },
        {
            "location": "/reference/#booleans",
            "text": "variable := true\nvariable := false",
            "title": "Booleans"
        },
        {
            "location": "/reference/#dates-and-time",
            "text": "variable := 2000-01-01T00:00:00.000Z\nvariable := 2000-01-01T00:00:00.000+00:15",
            "title": "Dates and time"
        },
        {
            "location": "/reference/#expression-and-operators",
            "text": "",
            "title": "Expression and operators"
        },
        {
            "location": "/reference/#precedence",
            "text": "One can adjust the precedence of expressions in VTL using the parenthesis ( (  and  ) )  \n      \nvariable := ( expression )",
            "title": "Precedence"
        },
        {
            "location": "/reference/#arithmetic-operators",
            "text": "The multiplication, division, addition and subtraction operators can be\nused with Float and Integer types.  \n      \nvariable := 1 + 2 / 3 * 4\n      \n   If Floats and Integers are mixed in the same arithmetic expression the\nresulting number will be Float  \n      \nfloatVariable := 1 + 2.0\nfloatVariable := 1 * 1.0",
            "title": "Arithmetic operators"
        },
        {
            "location": "/reference/#concatenation-operator",
            "text": "The concatenation operator  ||  concatenate two strings.  \n     \ncontac := [data] {\n    result := left || \" \" || right\n} \n     \nleft[I,String],right[I,String]\nHello,World\nnull,World\nHello,null",
            "title": "Concatenation operator"
        },
        {
            "location": "/reference/#string-functions",
            "text": "strings := [data] {\n    withTrailingSpc := \"   \" || value || \"   \",\n    rightTrim := \"[\" || rtrim(withTrailingSpc) || \"]\",\n    leftTrim := \"[\" || ltrim(withTrailingSpc) || \"]\",\n    'trim' := \"[\" || trim(withTrailingSpc) || \"]\",\n    noTrim := \"[\" || withTrailingSpc || \"]\"\n} \n     \nid[I,Long],value[M,String]\n1L,Hello World!",
            "title": "String functions"
        },
        {
            "location": "/reference/#trim-ltrim-and-rtrim-functions",
            "text": "The  trim ,  ltrim  and  rtrim  take a  String  as input and return a String .  The  ltrim  and  rtrim  functions remove leading (to the left and\ntrailing (to the right) white characters from the given  String ,\nrespectively.  The  trim  functions remove both the leading and trailing white\ncharacters.  \n    String   trim(String value)\n    String  rtrim(String value)\n    String  ltrim(String value)",
            "title": "Trim, ltrim and rtrim functions"
        },
        {
            "location": "/reference/#upper-and-lower-function",
            "text": "String  upper(String value)\n    String  lower(String value)  The  upper  function transforms all of the characters of the given String  to upper case. The  lower  functions transforms all the\ncharacters of the given  String  to lower case.",
            "title": "Upper and lower function"
        },
        {
            "location": "/reference/#mathematical-functions",
            "text": "In addition to the arithmetic operators, basic mathematical operations\nare available as functions.  \n     \nmath := [data] {\n    posInteger := data.value,\n    negInteger := data.value * -1,\n    posFloat := data.value / 10,\n    negFloat := negInteger / 10,\n    absFn   := abs(negFloat),\n    logFn   := log(posInteger, posInteger),\n    ceilFn  := ceil(posFloat * 5),\n    floorFn := floor(posFloat * 5),\n    expFn   := exp(posFloat),\n    lnFn    := ln(posInteger),\n    logFn   := log(posInteger, posInteger),\n    powerFn := power(posInteger, posInteger),\n    nrootFn := nroot(posInteger, posInteger),\n    roundFn := round(posFloat, 2)\n} \n     \nvalue[I,Long]\n1L\n3L\n4L\n5L\n6L\n7L\n8L\n9L\n10L",
            "title": "Mathematical functions"
        },
        {
            "location": "/reference/#abs-function",
            "text": "Float   abs(Float value)\n    Integer abs(Integer value)  The  abs  function takes an  Integer  or a Float  value and returns its absolute value.",
            "title": "Abs function"
        },
        {
            "location": "/reference/#ceil-and-floor-functions",
            "text": "Integer floor(Float value)\n    Integer ceil(Float value)  The  ceil  and  floor  functions take as input a  Float  value and\nreturn an  Integer  value.  ceil  will return the smallest  Integer  value that is greater than the\ngiven value.  floor  will return the largest  Integer  value that is smaller than the\ngiven value.",
            "title": "Ceil and Floor functions"
        },
        {
            "location": "/reference/#trunc-and-round-functions",
            "text": "Float trunc(Float value, Integer decimals)\n    Float floor(Float value, Integer decimals)  The  trunc  and 'round' functions take as input a  Float  value and an Integer  that represent a number of decimals. Both  trunc  and  round \nreturn a  Float .  trunc  will wil truncate to the decimals whereas  round  will round up\nto the decimals.",
            "title": "Trunc and Round functions"
        },
        {
            "location": "/reference/#ln-function-napierian-logarithm",
            "text": "Float ln(Float value)",
            "title": "Ln function (Napierian logarithm)"
        },
        {
            "location": "/reference/#exp-function",
            "text": "Float exp(Integer value)\n    Float exp(Float value)",
            "title": "Exp function"
        },
        {
            "location": "/reference/#power-function",
            "text": "Float power(Float value, Float exponent)",
            "title": "Power function"
        },
        {
            "location": "/reference/#sqrt-function",
            "text": "Float sqrt(Float value)",
            "title": "Sqrt function"
        },
        {
            "location": "/reference/#nroot-function",
            "text": "Float nroot(Float value, Float n)",
            "title": "Nroot function"
        },
        {
            "location": "/reference/#datasets",
            "text": "",
            "title": "Datasets"
        },
        {
            "location": "/reference/#record",
            "text": "",
            "title": "Record"
        },
        {
            "location": "/reference/#product",
            "text": "",
            "title": "Product"
        },
        {
            "location": "/reference/#_1",
            "text": "",
            "title": "()"
        },
        {
            "location": "/reference/#join-expressions",
            "text": "",
            "title": "Join expressions"
        },
        {
            "location": "/reference/#inner-join",
            "text": "innerJoin := [inner left, right] {\n    filter true\n}\n     \n     \nid[I,String],measure[M,String],attribute[A,String]\n3,left value 3, left attribute 3\n4,left value 4, left attribute 4\n5,left value 5, left attribute 5\n6,left value 6, left attribute 6\n     \n     \nid[I,String],measure[M,String],attribute[A,String]\n1,right value 1, right attribute 1\n2,right value 2, right attribute 2\n3,right value 3, right attribute 3\n4,right value 4, right attribute 4",
            "title": "Inner join"
        },
        {
            "location": "/reference/#outer-join",
            "text": "outerJoin := [outer left, right] {\n    filter true\n}\n     \n     \nid1[I,String],id2[I,String],measure[M,String],attribute[A,String]\n1,3,left value 3, left attribute 3\n1,4,left value 4, left attribute 4\n1,5,left value 5, left attribute 5\n1,6,left value 6, left attribute 6\n     \n     \nid1[I,String],id2[I,String],measure[M,String],attribute[A,String]\n1,1,right value 1, right attribute 1\n1,2,right value 2, right attribute 2\n1,3,right value 3, right attribute 3\n1,4,right value 4, right attribute 4",
            "title": "Outer join"
        },
        {
            "location": "/reference/#fold-clause",
            "text": "Fold transposes a single data point of the input Dataset into several\ndata points. It adds Identifier dim and measure msr to the resulting\nDataset, inserts into the resulting Dataset a data point for each value\nA in the element list and assigns to the inserted data point dim = A and\nmsr = value of measure A in the input Dataset.  When measure A is null then fold does not create a data point for that\nmeasure. Note that in general unfolding and folding are not exactly\nsymmetric operations, i.e. in some cases the fold operation applied to\nthe unfolded Dataset does not recreate exactly the original Dataset\n(before unfolding).  \n     \nfolded := [population] {\n    fold '0-14', '15-24', '25-64', '65+' to age, percent\n}\nunfolded := [folded] {\n    unfold age, percent to \"0-14\", \"15-24\"\n}\n     \n     \ncountry[I,String],0-14[M,String],15-24[M,String],25-64[M,String],65+[M,String]\nFrance ,18.1%,12.2%,51.0%,18.7%\nNorway ,18.6%,13.0%,52.0%,16.4%\nItaly  ,14.0%,9.8%,54.4%,21.7%\nSweden ,17.3%,12.2%,50.5%,20.0%",
            "title": "Fold clause"
        },
        {
            "location": "/reference/#unfold",
            "text": "unfolded := [colors] {\n    unfold color, wavelength to \"indigo\", \"blue\", \"yellow\"\n}\n     \n     \ncolor[I,String],wavelength[M,String]\nblue, 475nm\nindigo, 445nm\norange, 570nm\nred, 650nm\nviolet, 400 nm\nyellow, 510nm",
            "title": "Unfold"
        },
        {
            "location": "/reference/#check-operators",
            "text": "The check operators are used to validate data sets. Three check operator\n variants are available, check with rule sets, check with hierarchical\n rule sets and check with single boolean rule.  The return value of the check function depend of parameters.\nWhen used with the parameter \"condition\", the resulting dataset will only\n contain a condition measure of type Boolean indicating if the DataPoint\n is valid according to the rule set, hierarchical rule set or boolean\n expression.\nWith the parameter \"measures\", the resulting dataset contains all the\nmeasures of the input dataset.",
            "title": "Check operators"
        },
        {
            "location": "/reference/#check-with-single-rule",
            "text": "folded := check(data.valid <> \"na\")\n     \n     \ncountry[I,String],population[M,String]\nFrance , 64M\nNorway , 5M\nItaly  , na\nSweden , 9M",
            "title": "Check with single rule"
        },
        {
            "location": "/reference/#conditional-operators",
            "text": "",
            "title": "Conditional operators"
        },
        {
            "location": "/reference/#nvl",
            "text": "The operator nvl replaces null values with a value given as a parameter. \n     \njoin := [outer left, right] {\n    nvl_result := nvl(right.value, \"was null\")\n}\n     \n     \nid1[I,String],id2[I,String],value[M,String],attribute[A,String]\n1,3,left value 3, left attribute 3\n1,4,left value 4, left attribute 4\n1,5,left value 5, left attribute 5\n1,6,left value 6, left attribute 6\n     \n     \nid1[I,String],id2[I,String],value[M,String],attribute[A,String]\n1,1,right value 1, right attribute 1\n1,2,right value 2, right attribute 2\n1,3,right value 3, right attribute 3\n1,4,right value 4, right attribute 4",
            "title": "nvl"
        },
        {
            "location": "/reference/#boolean-operators",
            "text": "",
            "title": "Boolean operators"
        },
        {
            "location": "/reference/#null-operators",
            "text": "VTL adopts 3VL (three-value logic); null is not considered a \"value\",\n but rather a marker (or placeholder) indicating the absence of value.     p  q  p   OR  q  p   AND  q  p   =  q      True  True  True  True  True    True  False  True  False  False    True  Unknown  True  Unknown  Unknown    False  True  True  False  False    False  False  False  False  True    False  Unknown  Unknown  False  Unknown    Unknown  True  True  Unknown  Unknown    Unknown  False  Unknown  False  Unknown    Unknown  Unknown  Unknown  Unknown  Unknown        p  NOT  p      True  False    False  True    Unknown  Unknown     Null in boolean operators evaluates to false. In order to test whether\n or not a value is null one can use the postfix operator  is null  or\n  is not null  as well as the functional equivalents  isnull()  or\n  not(isnull()) .  \n     \npostfixIsNull := [data] {\n    filter value is null\n}\npostfixIsNotNull := [data] {\n    filter value is not null\n}\n\nfunctionalIsNull := [data] {\n    filter isnull(value) \n}\n\nfunctionalIsNotNull := [data] {\n    filter not(isnull(value))\n}\n     \n     \ncountry[I,String],value[M,String]\nNull , null\nNotNull , value",
            "title": "Null operators"
        },
        {
            "location": "/reference/#hierarchy-operator",
            "text": "The hierarchy operator aggregates all measures of a dataset mapping one\nidentifier with a hierarchy.  For instance, consider the following hierarchy:   World  Europe  Eastern Europe  Poland  Ukraine  Romania  Hungary  Slovakia  ...    Northern Europe  Denmark  Norway  Sweden  Iceland  ...    Southern Europe  Italy  Spain  Portugal  ...    Western Europe  Belgium  France  ...         \n     \nresult := hierarchy(data, data.region, world, true)\n     \n     \nyear[I,String],region[I,String],pop[M,Long]\n2000,Belgium,2000L\n2000,Denmark,2000L\n2000,France,2000L\n2000,Hungary,2000L\n2000,Iceland,2000L\n2000,Italy,2000L\n2000,Norway,2000L\n2000,Poland,2000L\n2000,Portugal,2000L\n2000,Romania,2000L\n2000,Slovakia,2000L\n2000,Spain,2000L\n2000,Sweden,2000L\n2000,Ukraine,2000L\n2002,Belgium,2002L\n2002,Denmark,2002L\n2002,France,2002L\n2002,Hungary,2002L\n2002,Iceland,2002L\n2002,Italy,2002L\n2002,Norway,2002L\n2002,Poland,2002L\n2002,Portugal,2002L\n2002,Romania,2002L\n2002,Slovakia,2002L\n2002,Spain,2002L\n2002,Sweden,2002L\n2002,Ukraine,2002L\n2004,Belgium,2004L\n2004,Denmark,2004L\n2004,France,2004L\n2004,Hungary,2004L\n2004,Iceland,2004L\n2004,Italy,2004L\n2004,Norway,2004L\n2004,Poland,2004L\n2004,Portugal,2004L\n2004,Romania,2004L\n2004,Slovakia,2004L\n2004,Spain,2004L\n2004,Sweden,2004L\n2004,Ukraine,2004L\n     \n     \nfrom[I,String],to[I,String],sign[M,String]\nWestern Europe,Europe,+\nEastern Europe,Europe,+\nSouthern Europe,Europe,+\nNorthern Europe,Europe,+\nBelgium,Western Europe,+\nDenmark,Northern Europe,+\nFrance,Western Europe,+\nHungary,Eastern Europe,+\nIceland,Northern Europe,+\nItaly,Southern Europe,+\nNorway,Northern Europe,+\nPoland,Eastern Europe,+\nPortugal,Southern Europe,+\nRomania,Eastern Europe,+\nSlovakia,Eastern Europe,+\nSpain,Southern Europe,+\nSweden,Northern Europe,+\nUkraine,Eastern Europe,+",
            "title": "Hierarchy operator"
        },
        {
            "location": "/reference/#string-operators",
            "text": "",
            "title": "String operators"
        },
        {
            "location": "/reference/#substr",
            "text": "String substr(Integer startPosition, Integer length)  The  substr  operator takes as input  startPosition  which is the index of the character\nin the string from which the substring is performed and  length  which is the number of\nthe characters in the string to be taken starting from  startPosition . \nThe operator returns a  String  value.  \n     \nresult := [data] {\n    sub := substr(M1, 5, 6)\n}\n     \n     \nID[I,String],M1[M,String]\n1 , hello world\n2 , hello\n3 , null",
            "title": "substr"
        },
        {
            "location": "/reference/#date_from_string",
            "text": "The operator date_from_string converts a string into a date. \n     \njoin := [left] {\n    b := date_from_string(M1, \"YYYY\")\n}\n     \n     \nID[I,String],M1[M,String]\n1 , 2016\n2 , 2017\n3 , null",
            "title": "date_from_string"
        },
        {
            "location": "/reference/#operators-outside-the-specification",
            "text": "",
            "title": "Operators outside the specification"
        },
        {
            "location": "/reference/#integer_from_string",
            "text": "Note \n    This operator is not part of the VTL 1.1 specification.  \n    Integer integer_from_string(String value)  The  integer_from_string  operator takes as input a  String  value and returns an  Integer  value. \n     \njoin := [data] {\n    integerFromString := integer_from_string(M1)\n}\n     \n     \nID[I,String],M1[M,String]\n1 , 10\n2 , 101\n3 , null",
            "title": "integer_from_string"
        },
        {
            "location": "/reference/#float_from_string",
            "text": "Note \n    This operator is not part of the VTL 1.1 specification.  \n    Float float_from_string(String value)  The  float_from_string  operator takes as input a  String  value and returns an  Float  value. The input\nvalue format is described in detail in section 3.10.2 of the Java Language Specification.\nAdditionally a comma ( , ) is allowed as a decimal point. \n     \njoin := [data] {\n    floatFromString := float_from_string(M1)\n}\n     \n     \nID[I,String],M1[M,String]\n1  , -0.1e-10\n2  , -0.1e10\n3  , -0.1e+10\n4  , 0.1e-10\n5  , 0.1e10\n6  , 0.1e+10\n7  , +0.1e-10\n8  , +0.1e10\n9  , +0.1e+10\n10 , 0.01\n11 , -0.001\n12 , +0.0001\n13 , null",
            "title": "float_from_string"
        },
        {
            "location": "/reference/#string_from_number",
            "text": "Note \n    This operator is not part of the VTL 1.1 specification.  \n    String string_from_number(Number value)  The  string_from_number  operator takes as input a  Number  value and returns an  String  value.\nThe exact result of this operator is described in the documentation of  java.lang.Double.toString() \nand  java.lang.Long.toString()  methods available at  Oracle Java Help Center . \n     \njoin := [data] {\n    stringFromInteger := string_from_number(M1),\n    stringFromFloat := string_from_number(M2)\n}\n     \n     \nID[I,String],M1[M,Long],M2[M,Double]\n1 , 10, 10.01\n2 , 0, -0.001\n3 , null, null",
            "title": "string_from_number"
        },
        {
            "location": "/playground/",
            "text": "",
            "title": "Playground"
        }
    ]
}